//
// NotificationMessage.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct NotificationMessage: Codable, Hashable {

    public var entityId: String?
    public var entityType: [String]
    public var changedAt: Date?
    public var changedBy: String?
    public var typeOffChange: Int?
    public var displayName: String?
    public var accountId: String?
    public var sequenceNumber: Int64?
    public var entityRefId: String?
    public var entityParentId: String?
    public var metadata: AnyCodable?
    public var previousState: Int?
    public var currentState: Int?
    public var subscriptionId: String
    /** Constraints of this subscription like gauranteedDelivery */
    public var constraints: [String]?
    /** /user/queue/callbacks */
    public var topic: String?
    public var meta: MetaBasic?
    public var data: [EntityChangeSubscription]?
    public var errors: [ModelError]?

    public init(entityId: String? = nil, entityType: [String], changedAt: Date? = nil, changedBy: String? = nil, typeOffChange: Int? = nil, displayName: String? = nil, accountId: String? = nil, sequenceNumber: Int64? = nil, entityRefId: String? = nil, entityParentId: String? = nil, metadata: AnyCodable? = nil, previousState: Int? = nil, currentState: Int? = nil, subscriptionId: String, constraints: [String]? = nil, topic: String? = nil, meta: MetaBasic? = nil, data: [EntityChangeSubscription]? = nil, errors: [ModelError]? = nil) {
        self.entityId = entityId
        self.entityType = entityType
        self.changedAt = changedAt
        self.changedBy = changedBy
        self.typeOffChange = typeOffChange
        self.displayName = displayName
        self.accountId = accountId
        self.sequenceNumber = sequenceNumber
        self.entityRefId = entityRefId
        self.entityParentId = entityParentId
        self.metadata = metadata
        self.previousState = previousState
        self.currentState = currentState
        self.subscriptionId = subscriptionId
        self.constraints = constraints
        self.topic = topic
        self.meta = meta
        self.data = data
        self.errors = errors
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case entityId
        case entityType
        case changedAt
        case changedBy
        case typeOffChange
        case displayName
        case accountId
        case sequenceNumber
        case entityRefId
        case entityParentId
        case metadata
        case previousState
        case currentState
        case subscriptionId
        case constraints
        case topic
        case meta
        case data
        case errors
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(entityId, forKey: .entityId)
        try container.encode(entityType, forKey: .entityType)
        try container.encodeIfPresent(changedAt, forKey: .changedAt)
        try container.encodeIfPresent(changedBy, forKey: .changedBy)
        try container.encodeIfPresent(typeOffChange, forKey: .typeOffChange)
        try container.encodeIfPresent(displayName, forKey: .displayName)
        try container.encodeIfPresent(accountId, forKey: .accountId)
        try container.encodeIfPresent(sequenceNumber, forKey: .sequenceNumber)
        try container.encodeIfPresent(entityRefId, forKey: .entityRefId)
        try container.encodeIfPresent(entityParentId, forKey: .entityParentId)
        try container.encodeIfPresent(metadata, forKey: .metadata)
        try container.encodeIfPresent(previousState, forKey: .previousState)
        try container.encodeIfPresent(currentState, forKey: .currentState)
        try container.encode(subscriptionId, forKey: .subscriptionId)
        try container.encodeIfPresent(constraints, forKey: .constraints)
        try container.encodeIfPresent(topic, forKey: .topic)
        try container.encodeIfPresent(meta, forKey: .meta)
        try container.encodeIfPresent(data, forKey: .data)
        try container.encodeIfPresent(errors, forKey: .errors)
    }
}

