//
// CreateContestForCompetitionRequest.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct CreateContestForCompetitionRequest: Codable, Hashable {

    /** A list of custom field entries */
    public var customFields: [String: AnyCodable]?
    /** A list of id's used to tag models */
    public var tags: [String]?
    public var metadata: [String: String]?
    /** A unique identifier of a Competition */
    public var competitionId: String
    /** The row number for displaying the Contest in a table */
    public var row: Int
    /** To what round does the contest belong */
    public var round: Int
    /** Is used for more complex Competitions e.g. multi round competitions where round 1 group stage matched round 2 */
    public var groupStage: Int?
    /** The name of the group stages */
    public var groupStageLabel: String?
    /** A list of Ziqni contest identifiers to allow contests chaining. When a Progression competition is active and you have a 2 round competition the first round has to reference the second round then this parameter becomes mandatory instead of Optional. */
    public var entrantsFromContest: [String]?
    /** A name for the Contest. Can be translated */
    public var name: String
    /** A name for the Contest. Can be translated */
    public var description: String?
    /** A name for the Contest. Can be translated */
    public var termsAndConditions: String?
    public var roundType: RoundType
    /** Maximum number of entrants for the contest */
    public var maxNumberOfEntrants: Int?
    /** Minimum number of entrants for the contest */
    public var minNumberOfEntrants: Int
    public var rules: [Rule]?
    /** ISO8601 timestamp for when a Contest should start. All records are stored in UTC time zone */
    public var scheduledStartDate: Date
    /** ISO8601 timestamp for when a Contest should end. All records are stored in UTC time zone */
    public var scheduledEndDate: Date
    public var strategies: Strategy
    public var translations: [Translation]?
    public var rewards: [CreateRewardRequest]?
    /** Additional constraints */
    public var constraints: [String]

    public init(customFields: [String: AnyCodable]? = nil, tags: [String]? = nil, metadata: [String: String]? = nil, competitionId: String, row: Int, round: Int, groupStage: Int? = nil, groupStageLabel: String? = nil, entrantsFromContest: [String]? = nil, name: String, description: String? = nil, termsAndConditions: String? = nil, roundType: RoundType, maxNumberOfEntrants: Int? = nil, minNumberOfEntrants: Int, rules: [Rule]? = nil, scheduledStartDate: Date, scheduledEndDate: Date, strategies: Strategy, translations: [Translation]? = nil, rewards: [CreateRewardRequest]? = nil, constraints: [String]) {
        self.customFields = customFields
        self.tags = tags
        self.metadata = metadata
        self.competitionId = competitionId
        self.row = row
        self.round = round
        self.groupStage = groupStage
        self.groupStageLabel = groupStageLabel
        self.entrantsFromContest = entrantsFromContest
        self.name = name
        self.description = description
        self.termsAndConditions = termsAndConditions
        self.roundType = roundType
        self.maxNumberOfEntrants = maxNumberOfEntrants
        self.minNumberOfEntrants = minNumberOfEntrants
        self.rules = rules
        self.scheduledStartDate = scheduledStartDate
        self.scheduledEndDate = scheduledEndDate
        self.strategies = strategies
        self.translations = translations
        self.rewards = rewards
        self.constraints = constraints
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case customFields
        case tags
        case metadata
        case competitionId
        case row
        case round
        case groupStage
        case groupStageLabel
        case entrantsFromContest
        case name
        case description
        case termsAndConditions
        case roundType
        case maxNumberOfEntrants
        case minNumberOfEntrants
        case rules
        case scheduledStartDate
        case scheduledEndDate
        case strategies
        case translations
        case rewards
        case constraints
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(customFields, forKey: .customFields)
        try container.encodeIfPresent(tags, forKey: .tags)
        try container.encodeIfPresent(metadata, forKey: .metadata)
        try container.encode(competitionId, forKey: .competitionId)
        try container.encode(row, forKey: .row)
        try container.encode(round, forKey: .round)
        try container.encodeIfPresent(groupStage, forKey: .groupStage)
        try container.encodeIfPresent(groupStageLabel, forKey: .groupStageLabel)
        try container.encodeIfPresent(entrantsFromContest, forKey: .entrantsFromContest)
        try container.encode(name, forKey: .name)
        try container.encodeIfPresent(description, forKey: .description)
        try container.encodeIfPresent(termsAndConditions, forKey: .termsAndConditions)
        try container.encode(roundType, forKey: .roundType)
        try container.encodeIfPresent(maxNumberOfEntrants, forKey: .maxNumberOfEntrants)
        try container.encode(minNumberOfEntrants, forKey: .minNumberOfEntrants)
        try container.encodeIfPresent(rules, forKey: .rules)
        try container.encode(scheduledStartDate, forKey: .scheduledStartDate)
        try container.encode(scheduledEndDate, forKey: .scheduledEndDate)
        try container.encode(strategies, forKey: .strategies)
        try container.encodeIfPresent(translations, forKey: .translations)
        try container.encodeIfPresent(rewards, forKey: .rewards)
        try container.encode(constraints, forKey: .constraints)
    }
}

