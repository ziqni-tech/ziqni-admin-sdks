//
// MemberAward.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** This is the Member Award model */
public struct MemberAward: Codable, Hashable {

    /** A unique identifier of a Reward */
    public var rewardId: String
    /** The type of the Reward */
    public var rewardType: String
    /** A unique id of the Reward Type */
    public var rewardTypeId: String
    /** Numerical value of the reward that will be issued based on the reward type */
    public var rewardValue: Double
    /** Delay of issuing a reward in minutes */
    public var delay: Int?
    public var entityType: EntityType
    /** The Id of the contest or achievement related to this Award. Dependant on entityType */
    public var entityId: String
    /** ISO8601 timestamp for when an Award is available until a specific point in time. All records are stored in UTC time zone. * There can only be one time definition used for claim period either \"pointInTime\" or \"period\" */
    public var pointInTime: Date?
    /** Claimable duration in minutes, this value will set the controls until when the award is claimable. * There can only be one time definition used for claim period either \"pointInTime\" or \"period\" */
    public var period: Int?
    /** A list of Strings of groups that the reward belongs to. */
    public var tags: [String]?
    public var metadata: [String: String]?
    /** Additional constraints */
    public var constraints: [String]
    /** ISO8601 timestamp for when an Award is claimed. All records are stored in UTC time zone. * */
    public var claimedTimestamp: Date?
    /** A unique system generated identifier */
    public var id: String
    /** This is the space name which is linked to the account */
    public var spaceName: String
    /** ISO8601 timestamp for when a Model was created. All records are stored in UTC time zone */
    public var created: Date

    public init(rewardId: String, rewardType: String, rewardTypeId: String, rewardValue: Double, delay: Int? = nil, entityType: EntityType, entityId: String, pointInTime: Date? = nil, period: Int? = nil, tags: [String]? = nil, metadata: [String: String]? = nil, constraints: [String], claimedTimestamp: Date? = nil, id: String, spaceName: String, created: Date) {
        self.rewardId = rewardId
        self.rewardType = rewardType
        self.rewardTypeId = rewardTypeId
        self.rewardValue = rewardValue
        self.delay = delay
        self.entityType = entityType
        self.entityId = entityId
        self.pointInTime = pointInTime
        self.period = period
        self.tags = tags
        self.metadata = metadata
        self.constraints = constraints
        self.claimedTimestamp = claimedTimestamp
        self.id = id
        self.spaceName = spaceName
        self.created = created
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case rewardId
        case rewardType
        case rewardTypeId
        case rewardValue
        case delay
        case entityType
        case entityId
        case pointInTime
        case period
        case tags
        case metadata
        case constraints
        case claimedTimestamp
        case id
        case spaceName
        case created
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(rewardId, forKey: .rewardId)
        try container.encode(rewardType, forKey: .rewardType)
        try container.encode(rewardTypeId, forKey: .rewardTypeId)
        try container.encode(rewardValue, forKey: .rewardValue)
        try container.encodeIfPresent(delay, forKey: .delay)
        try container.encode(entityType, forKey: .entityType)
        try container.encode(entityId, forKey: .entityId)
        try container.encodeIfPresent(pointInTime, forKey: .pointInTime)
        try container.encodeIfPresent(period, forKey: .period)
        try container.encodeIfPresent(tags, forKey: .tags)
        try container.encodeIfPresent(metadata, forKey: .metadata)
        try container.encode(constraints, forKey: .constraints)
        try container.encodeIfPresent(claimedTimestamp, forKey: .claimedTimestamp)
        try container.encode(id, forKey: .id)
        try container.encode(spaceName, forKey: .spaceName)
        try container.encode(created, forKey: .created)
    }
}

